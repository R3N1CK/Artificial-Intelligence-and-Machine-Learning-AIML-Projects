# -*- coding: utf-8 -*-
"""Face_mask_segmentation_Questions_Project_CV_AIML_Online.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fyVIwOHIIRaopuOm-2qqs55n1ZWqDCAX

# Instructions
- Some parts of the code are already done for you
- You need to execute all the cells
- You need to add the code where ever you see `"#### Add your code here ####"`
- Marks are mentioned along with the cells

# Face Mask Segmentation
Task is to predict the boundaries(mask) around the face in a given image.

## Dataset
Faces in images marked with bounding boxes. Have around 500 images with around 1100 faces manually tagged via bounding box.

### Mount Google drive if you are using google colab
- We recommend using Google Colab as you can face memory issues and longer runtimes while running on local
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.x

from google.colab import drive
drive.mount('/content/drive')

"""### Change current working directory to project folder (1 mark)"""

import os
os.chdir("/content/drive/My Drive/PROJECT/")

"""### Load the "images.npy" file (2 marks)
- This file contains images with details of bounding boxes
"""

import numpy as np
data = np.load('/content/drive/My Drive/PROJECT/images.npy',allow_pickle=True)

"""### Check one sample from the loaded "images.npy" file  (2 marks)
Hint - print data[10][1]
"""

print (data[10][1])
print(data.shape)

"""### Set image dimensions   (1 mark)
- Initialize image height, image width with value: 224
"""

IMAGE_WIDTH = 224
IMAGE_HEIGHT = 224

"""### Create features and labels
- Here feature is the image
- The label is the mask
- Images will be stored in "X_train" array
- Masks will be stored in "masks" array
"""

import cv2
from tensorflow.keras.applications.mobilenet import preprocess_input

masks = np.zeros((int(data.shape[0]), IMAGE_HEIGHT, IMAGE_WIDTH))
X_train = np.zeros((int(data.shape[0]), IMAGE_HEIGHT, IMAGE_WIDTH, 3))
for index in range(data.shape[0]):
    img = data[index][0]
    img = cv2.resize(img, dsize=(IMAGE_HEIGHT, IMAGE_WIDTH), interpolation=cv2.INTER_CUBIC)
    try:
      img = img[:, :, :3]
    except:
      continue
    X_train[index] = preprocess_input(np.array(img, dtype=np.float32))
    for i in data[index][1]:
        x1 = int(i["points"][0]['x'] * IMAGE_WIDTH)
        x2 = int(i["points"][1]['x'] * IMAGE_WIDTH)
        y1 = int(i["points"][0]['y'] * IMAGE_HEIGHT)
        y2 = int(i["points"][1]['y'] * IMAGE_HEIGHT)
        masks[index][y1:y2, x1:x2] = 1

"""### Print the shape of X_train and mask array  (1 mark)"""

print (X_train.shape)

print (masks.shape)

"""### Print a sample image and image array"""

from matplotlib import pyplot
n = 10
print(X_train[n])
pyplot.imshow(X_train[n])

pyplot.imshow(masks[n])

"""## Create the model (10 marks)
- Add MobileNet as model with below parameter values
  - input_shape: IMAGE_HEIGHT, IMAGE_WIDTH, 3
  - include_top: False
  - alpha: 1.0
  - weights: "imagenet"
- Add UNET architecture layers
  - This is the trickiest part of the project, you need to research and implement it correctly
"""

from tensorflow.keras.applications.mobilenet import MobileNet
from tensorflow.keras.layers import Concatenate, UpSampling2D, Conv2D, Reshape
from tensorflow.keras.models import Model


def create_model(trainable=True):
    model = MobileNet(input_shape=(IMAGE_HEIGHT, IMAGE_WIDTH, 3), include_top=False,alpha= 1.0,weights= "imagenet")
    for layer in model.layers:
        layer.trainable = trainable

    block = model.get_layer("conv_pw_1_relu").output
    block1 = model.get_layer("conv_pw_3_relu").output
    block2 = model.get_layer("conv_pw_5_relu").output
    block3 = model.get_layer("conv_pw_11_relu").output
    block4 = model.get_layer("conv_pw_13_relu").output
    
    x = Concatenate()([UpSampling2D()(block4), block3])
    x = Concatenate()([UpSampling2D()(x), block2])
    x = Concatenate()([UpSampling2D()(x), block1])
    x = Concatenate()([UpSampling2D()(x), block])
    x = UpSampling2D()(x)
    x = Conv2D(1, kernel_size=1, activation="sigmoid")(x)

    x = Reshape((IMAGE_HEIGHT, IMAGE_WIDTH))(x)

    return Model(inputs=model.input, outputs=x)

"""### Call the create_model function"""

# Give trainable=False as argument, if you want to freeze lower layers for fast training (but low accuracy)
model = create_model()

# Print summary
model.summary()

"""### Define dice coefficient function (5 marks)
- Create a function to calculate dice coefficient
"""

import tensorflow as tensorflow

def dice_coefficient(y_true, y_pred):
    numerator = 2 * tensorflow.reduce_sum(y_true * y_pred)
    denominator = tensorflow.reduce_sum(y_true + y_pred)

    return numerator / (denominator + epsilon())

"""### Define loss"""

from tensorflow.keras.losses import binary_crossentropy
from tensorflow.keras.backend import log, epsilon
def loss(y_true, y_pred):
    return binary_crossentropy(y_true, y_pred) - log(dice_coefficient(y_true, y_pred) + epsilon())

"""### Compile the model (2 marks)
- Complie the model using below parameters
  - loss: use the loss function defined above
  - optimizers: use Adam optimizer
  - metrics: use dice_coefficient function defined above
"""

model.compile(optimizer='Adam', loss=loss, metrics=[dice_coefficient])

"""### Define checkpoint and earlystopping"""

from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau
checkpoint = ModelCheckpoint("model-{loss:.2f}.h5", monitor="loss", verbose=1, save_best_only=True,
                             save_weights_only=True, mode="min", save_freq=1)
stop = EarlyStopping(monitor="loss", patience=5, mode="min")
reduce_lr = ReduceLROnPlateau(monitor="loss", factor=0.2, patience=5, min_lr=1e-6, verbose=1, mode="min")

"""### Fit the model (2 marks)
- Fit the model using below parameters
  - epochs: you can decide
  - batch_size: 1
  - callbacks: checkpoint, reduce_lr, stop
"""

model.fit(X_train,masks,epochs=1,batch_size=1,callbacks=[checkpoint,reduce_lr,stop])

"""### Get the predicted mask for a sample image   (3 marks)"""

prediction = model.predict(X_train)

n = 150
sample_image = X_train[n]

print(X_train[n])
pyplot.imshow(X_train[n])

print(prediction[n])
pyplot.imshow(prediction[n])

"""### Impose the mask on the image (3 marks)"""

pyplot.figure()
pyplot.subplot(1,2,1)
pyplot.imshow(X_train[n], 'gray', interpolation='none')
pyplot.subplot(1,2,2)
pyplot.imshow(X_train[n], 'gray', interpolation='none')
pyplot.imshow(prediction[n], 'jet', interpolation='none', alpha=0.7)
pyplot.show()